}
dbDisconnect(con_mssql)
dbDisconnect(con_sqlite)
db_path <- system.file("extdata", "eir_data.sqlite", package = "DNBCFoodTextClassifier")
con <- DBI::dbConnect(RSQLite::SQLite(), db_path)
View(con)
View(df)
View(con_sqlite)
runApp()
categories <- DBI::dbGetQuery(con, "SELECT * FROM categories;")
View(categories)
runApp()
attachment::att_amend_desc()
attachment::create_renv_for_dev(dev_pkg = c(
"renv",
"devtools",
"roxygen2",
"usethis",
"pkgload",
"golem",
"DBI",
"ggplot2",
"pROC",
"plotly",
"RSQLite",
"ggnewscale",
"shinyWidgets"
))
virtualSelectInput
?virtualSelectInput
runApp()
runApp()
shinyWidgetsGallery()
runApp()
shiny::runApp()
runApp()
categories <- DBI::dbGetQuery(con, "SELECT * FROM categories;")
runApp()
runApp()
db_path <- system.file("extdata", "eir_data.sqlite", package = "DNBCFoodTextClassifier")
con <- DBI::dbConnect(RSQLite::SQLite(), db_path)
categories <- DBI::dbGetQuery(con, "SELECT * FROM categories;")
View(categories)
filtered <- categories %>%
dplyr::filter(type == "sub_classif") %>%
dplyr::pull(name_exp,broad_categ)
filtered
categories %>%
+     dplyr::filter(type == "sub_classif")
filtered <- categories %>%
dplyr::filter(type == "sub_classif")
View(filtered)
filtered <- categories %>%
dplyr::filter(type == "sub_classif") %>% dplyr::select(name_exp,broad_categ)
head(filtered)
filtered %>%
group_by(broad_categ) %>%
summarise(items = list(name_exp)) %>%   # group into list-column
deframe() %>%                           # convert tibble to named list
lapply(as.list)
?summarise
?deframe
?lapply
filtered %>%
group_by(broad_categ) %>%
summarise(items = list(name_exp)) %>%   # group into list-column
tibble::deframe() %>%                           # convert tibble to named list
lapply(as.list)
filtered %>%
group_by(broad_categ) %>%
dplyr::summarise(items = list(name_exp)) %>%   # group into list-column
tibble::deframe() %>%                           # convert tibble to named list
lapply(as.list)
filtered %>%
dplyr::group_by(broad_categ) %>%
dplyr::summarise(items = list(name_exp)) %>%   # group into list-column
tibble::deframe() %>%                           # convert tibble to named list
lapply(as.list)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?selectizeInput
runApp()
treeInput
?treeInput
runApp()
runApp()
updateTreeInput()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
renv::status()
renv::update()
renv::record("renv@1.1.5")
renv::refresh()
renv::restore()
renv::snapshot()
renv::status()
shiny::runApp()
categories <- DBI::dbGetQuery(con, "SELECT * FROM categories;")
db_path <- system.file("extdata", "eir_data.sqlite", package = "DNBCFoodTextClassifier")
con <- DBI::dbConnect(RSQLite::SQLite(), db_path)
categories <- DBI::dbGetQuery(con, "SELECT * FROM categories;")
View(categories)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
## code to prepare `eir_db` dataset goes here
library(DBI)
library(RSQLite)
# Connect to MSSQL
con_mssql <- DBI::dbConnect(
drv      = RPostgres::Postgres(),
dbname   = "eir_data",
host     = "localhost",
port     = 5432,
user     = "postgres",
password = "siddhi"
)
# Connect to SQLite
con_sqlite <- dbConnect(RSQLite::SQLite(), "inst/extdata/eir_data.sqlite")
# List MSSQL tables
tables <- dbListTables(con_mssql)
# Copy each table to SQLite
for (tbl in tables) {
message("Exporting: ", tbl)
df <- dbReadTable(con_mssql, tbl)
dbWriteTable(con_sqlite, tbl, df, overwrite = TRUE)
}
dbDisconnect(con_mssql)
dbDisconnect(con_sqlite)
shiny::runApp()
runApp()
runApp()
runApp()
db_path <- system.file("extdata", "eir_data.sqlite", package = "DNBCFoodTextClassifier")
con <- DBI::dbConnect(RSQLite::SQLite(), db_path)
classif_type="major_classif"
food_category="Alcohol"
if (!exists("food_category") || is.null(food_category) || food_category == "" || is.na(food_category)) {
q1 <- paste0("SELECT category_id FROM categories WHERE type = '", classif_type, "'")
} else {
q1 <- paste0("SELECT category_id FROM categories WHERE type = '", classif_type,
"' AND name_exp = '", food_category, "'")
}
category_id <- DBI::dbGetQuery(con, q1)$category_id
q2 <- paste0("SELECT * FROM attributions WHERE category_id IN (", paste(category_id, collapse = ","),")")
attribution_data <- DBI::dbGetQuery(con, q2)
View(attribution_data)
classif_type="Broad Categories"
if (!exists("food_category") || is.null(food_category) || food_category == "" || is.na(food_category)) {
q1 <- paste0("SELECT category_id FROM categories WHERE type = '", classif_type, "'")
} else {
q1 <- paste0("SELECT category_id FROM categories WHERE type = '", classif_type,
"' AND name_exp = '", food_category, "'")
}
category_id <- DBI::dbGetQuery(con, q1)$category_id
q2 <- paste0("SELECT * FROM attributions WHERE category_id IN (", paste(category_id, collapse = ","),")")
attribution_data <- DBI::dbGetQuery(con, q2)
View(attribution_data)
quantile(attribution_data$attribution, c(0.025, 0.975))
2 * mean(attribution_data$attribution) - quantile(attribution_data$attribution, c(0.975, 0.025))
quantile(attribution_data$attribution, c(0.025, 0.975))
head(attribution_data)
library(dplyr)
library(boot)
# Define bootstrap function
boot_mean <- function(data, indices) {
d <- data[indices, ]
mean(d$attribution)
}
# Function to compute CI per input
bootstrap_ci <- function(df, n_boot = 1000, conf = 0.95) {
boot_res <- boot(df, boot_mean, R = n_boot)
ci <- boot.ci(boot_res, type = "perc", conf = conf)
data.frame(
mean = mean(df$attribution),
lower = ci$percent[4],
upper = ci$percent[5]
)
}
# Apply bootstrap per input
results <- attribution_data %>%
group_by(input) %>%
group_modify(~ bootstrap_ci(.x, n_boot = 2000)) %>%
ungroup()
# Apply bootstrap per input
results <- attribution_data %>%
# group_by(input) %>%
group_modify(~ bootstrap_ci(.x, n_boot = 2000)) %>%
ungroup()
View(results)
# Apply bootstrap per input
results <- attribution_data %>%
# group_by(input) %>%
group_modify(~ bootstrap_ci(.x, n_boot = 2000))
View(results)
attribution_data <- attribution_data %>% dplyr::filter(input==1)
View(attribution_data)
if (!exists("food_category") || is.null(food_category) || food_category == "" || is.na(food_category)) {
q1 <- paste0("SELECT category_id FROM categories WHERE type = '", classif_type, "'")
} else {
q1 <- paste0("SELECT category_id FROM categories WHERE type = '", classif_type,
"' AND name_exp = '", food_category, "'")
}
category_id <- DBI::dbGetQuery(con, q1)$category_id
q2 <- paste0("SELECT * FROM attributions WHERE category_id IN (", paste(category_id, collapse = ","),")")
attribution_data <- DBI::dbGetQuery(con, q2)
View(attribution_data)
library(dplyr)
library(boot)
attribution_data <- attribution_data %>% dplyr::filter(label==1)
# Define bootstrap function
boot_mean <- function(data, indices) {
d <- data[indices, ]
mean(d$attribution)
}
# Function to compute CI per input
bootstrap_ci <- function(df, n_boot = 1000, conf = 0.95) {
boot_res <- boot(df, boot_mean, R = n_boot)
ci <- boot.ci(boot_res, type = "perc", conf = conf)
data.frame(
mean = mean(df$attribution),
lower = ci$percent[4],
upper = ci$percent[5]
)
}
# Apply bootstrap per input
results <- attribution_data %>%
# group_by(input) %>%
group_modify(~ bootstrap_ci(.x, n_boot = 2000))
head(results)
library(dplyr)
library(boot)
attribution_data <- attribution_data %>% dplyr::filter(label==1)
# Define bootstrap function
boot_mean <- function(data, indices) {
d <- data[indices, ]
mean(d$attribution)
}
# Function to compute CI per input
bootstrap_ci <- function(df, n_boot = 1000, conf = 0.95) {
boot_res <- boot(df, boot_mean, R = n_boot)
ci <- boot.ci(boot_res, type = "perc", conf = conf)
data.frame(
mean = mean(df$attribution),
lower = ci$percent[4],
upper = ci$percent[5]
)
}
# Apply bootstrap per input
results <- attribution_data %>%
group_by(input) %>%
group_modify(~ bootstrap_ci(.x, n_boot = 2000)) %>%
ungroup()
library(dplyr)
library(boot)
attribution_data <- attribution_data %>% dplyr::filter(label==1)
bootstrap_ci <- function(df, n_boot = 2000, conf = 0.95) {
x <- df$attribution
m <- mean(x)
n <- length(x)
s <- sd(x)
# not enough data to estimate CI
if (n < 2) {
return(tibble::tibble(mean = m, lower = NA_real_, upper = NA_real_,
n = n, sd = s, note = "n<2"))
}
# all values identical -> zero-width CI at the mean
if (isTRUE(all.equal(s, 0))) {
return(tibble::tibble(mean = m, lower = m, upper = m,
n = n, sd = s, note = "sd=0"))
}
# otherwise try bootstrap percentile CI
boot_mean <- function(data, indices) mean(data[indices])
boot_res <- boot(x, boot_mean, R = n_boot)
ci <- tryCatch(
boot.ci(boot_res, type = "perc", conf = conf),
error = function(e) NULL
)
if (!is.null(ci) && !is.null(ci$percent)) {
tibble::tibble(mean = m, lower = ci$percent[4], upper = ci$percent[5],
n = n, sd = s, note = "bootstrap-perc")
} else {
# fallback: t-based CI
alpha <- 1 - conf
half_width <- qt(1 - alpha/2, df = n - 1) * s / sqrt(n)
tibble::tibble(mean = m, lower = m - half_width, upper = m + half_width,
n = n, sd = s, note = "t-fallback")
}
}
results <- attribution_data %>%
group_by(input) %>%
group_modify(~ bootstrap_ci(.x, n_boot = 2000, conf = 0.95)) %>%
ungroup()
head(results)
View(results)
library(boot)
bootstrap_ci <- function(x, n_boot = 2000, conf = 0.95) {
# if not enough variation, return NA or zero-width CI
if (length(unique(x)) < 2) {
return(tibble::tibble(
mean = mean(x),
lower = NA_real_,
upper = NA_real_,
ci_size = NA_real_
))
}
# define bootstrap function
boot_mean <- function(data, indices) mean(data[indices])
boot_res <- boot(x, boot_mean, R = n_boot)
ci <- boot.ci(boot_res, type = "perc", conf = conf)
tibble::tibble(
mean = mean(x),
lower = ci$percent[4],
upper = ci$percent[5],
ci_size = ci$percent[5] - ci$percent[4]
)
}
df_token_stats <- attribution_data %>%
filter(label == 1) %>%
group_by(input) %>%
summarise(
stats = list(bootstrap_ci(attribution, n_boot = 2000, conf = 0.95))
) %>%
tidyr::unnest(stats)
View(df_token_stats)
golem::add_module(name = "attrib_bar_plot")
View(attribution_data)
View(attribution_data)
ggplot2::ggplot(attribution_data, ggplot2::aes(x = attribution, y=input)) +
ggplot2::geom_bar(
position = "identity",
alpha = 0.6,
color = "black",
bins = 30
)
ggplot2::ggplot(attribution_data, ggplot2::aes(x = attribution, y=input)) +
ggplot2::geom_bar(
)
ggplot2::ggplot(attribution_data, ggplot2::aes(x = attribution, y=input)) +
ggplot2::geom_bar(
stat = "identity"
)
View(attribution_data)
View(attribution_data)
barplot_data <- attribution_data %>%
dplyr::arrange(attribution) %>%
top_n(10)
View(barplot_data)
ggplot2::ggplot(barplot_data, ggplot2::aes(x = attribution, y=input)) +
ggplot2::geom_bar(
stat = "identity"
)
ggplot2::ggplot(barplot_data, ggplot2::aes(x = attribution, y= reorder(input, -attribution))) +
ggplot2::geom_bar(
stat = "identity"
)
ggplot2::ggplot(barplot_data, ggplot2::aes(x = attribution, y= reorder(input, attribution))) +
ggplot2::geom_bar(
stat = "identity"
)
ggplot2::ggplot(barplot_data, ggplot2::aes(x = attribution, y= reorder(input, attribution))) +
ggplot2::geom_bar(
stat = "identity",
alpha = 0.6
)
runApp()
runApp()
runApp()
ggplot2::ggplot(barplot_data, ggplot2::aes(x = attribution, y = reorder(input, attribution))) +
ggplot2::geom_bar(
stat = "identity",
alpha = 0.6
) +
ggplot2::scale_fill_manual(
values = c("Positive" = "#ff7f0e"),
labels = "Positive"
)
ggplot2::ggplot(barplot_data, ggplot2::aes(x = attribution, y = reorder(input, attribution),
fill = label)) +
ggplot2::geom_bar(
stat = "identity",
alpha = 0.6
) +
ggplot2::scale_fill_manual(
values = c("Positive" = "#ff7f0e"),
labels = "Positive"
)
ggplot2::ggplot(barplot_data, ggplot2::aes(x = attribution, y = reorder(input, attribution),
fill = label)) +
ggplot2::geom_bar(
stat = "identity",
alpha = 0.6
) +
ggplot2::scale_fill_manual(
values = c(1 = "#ff7f0e"),
ggplot2::ggplot(barplot_data, ggplot2::aes(x = attribution, y = reorder(input, attribution),
fill = label)) +
ggplot2::geom_bar(
stat = "identity",
alpha = 0.6
) +
ggplot2::scale_fill_manual(
values = c("1" = "#ff7f0e"),
labels = "Positive"
)
barplot_data <- attribution_data %>%
dplyr::arrange(attribution) %>%
top_n(10) %>%
dplyr::mutate(label= as.character(label))
ggplot2::ggplot(barplot_data, ggplot2::aes(x = attribution, y = reorder(input, attribution),
fill = label)) +
ggplot2::geom_bar(
stat = "identity",
alpha = 0.6
) +
ggplot2::scale_fill_manual(
values = c("1" = "#ff7f0e"),
labels = "Positive"
)
ggplot2::ggplot(barplot_data, ggplot2::aes(x = attribution, y = reorder(input, attribution),
fill = label)) +
ggplot2::geom_bar(
stat = "identity",
alpha = 0.6
) +
ggplot2::scale_fill_manual(
values = c("1" = "#ff7f0e")
)
ggplot2::ggplot(barplot_data, ggplot2::aes(x = attribution, y = reorder(input, attribution),
fill = label)) +
ggplot2::geom_bar(
stat = "identity",
alpha = 0.6
) +
ggplot2::scale_fill_manual(
values = c("1" = "#ff7f0e")
) +
ggplot2::labs(
x = "Attribution score",
y = "Frequency",
title = "Token attributions for class 'Positive'"
) +
ggplot2::theme_minimal(base_size = 12) +
ggplot2::theme(
plot.title = ggplot2::element_text(face = "bold", size = 12),
legend.title = ggplot2::element_blank(),
legend.position="bottom"
)
ggplot2::ggplot(barplot_data, ggplot2::aes(x = attribution, y = reorder(input, attribution),
fill = label)) +
ggplot2::geom_bar(
stat = "identity",
alpha = 0.6
) +
ggplot2::scale_fill_manual(
values = c("1" = "#ff7f0e")
) +
ggplot2::labs(
x = "Attribution score",
y = "Frequency",
title = "Token attributions for class 'Positive'"
) +
ggplot2::theme_minimal(base_size = 12) +
ggplot2::theme(
plot.title = ggplot2::element_text(face = "bold", size = 12),
legend.title = ggplot2::element_blank(),
legend.position="none"
)
ggplot2::ggplot(barplot_data, ggplot2::aes(x = attribution, y = reorder(input, attribution),
fill = label)) +
ggplot2::geom_bar(
stat = "identity",
alpha = 0.6
) +
ggplot2::scale_fill_manual(
values = c("1" = "#ff7f0e")
) +
ggplot2::labs(
x = "Attribution score",
y = "Top 10 tokens",
title = "Token attributions for class 'Positive'"
) +
ggplot2::theme_minimal(base_size = 12) +
ggplot2::theme(
plot.title = ggplot2::element_text(face = "bold", size = 12),
legend.title = ggplot2::element_blank(),
legend.position="none"
)
